/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_eps_0x260_260_h
#define impl_type_eps_0x260_260_h






















#include "impl_type_eps_sassoftlimitleftflgtype.h"
#include "impl_type_eps_st_emergencyovertemptype.h"
#include "impl_type_eps_sasindexststype.h"
#include "impl_type_eps_st_emergencyundervoltagetype.h"
#include "impl_type_eps_st_emergencyecutype.h"
#include "impl_type_eps_st_emergencypowerlimittype.h"
#include "impl_type_eps_st_emergencyovervoltagetype.h"
#include "impl_type_eps_sassoftlimitrightflgtype.h"
#include "impl_type_double.h"
#include "impl_type_eps_st_emergencysensortype.h"
#include "impl_type_eps_f_ecutempvalidtype.h"
#include "impl_type_eps_s_safelampredtype.h"
#include "impl_type_eps_f_loadinfotype.h"
#include "impl_type_int32.h"
#include "impl_type_eps_st_dtcflagtype.h"
#include "impl_type_eps_st_emergencycaninterfacetype.h"
#include "impl_type_eps_s_warninglampyellowtype.h"
#include "impl_type_eps_st_emergencymotortype.h"


struct Eps_0x260_260 {
    ::Int32 eps_n_loadinfo;
    
    ::Eps_sassoftlimitrightflgType eps_sassoftlimitrightflg;
    
    ::Eps_st_emergencypowerlimitType eps_st_emergencypowerlimit;
    
    ::Eps_st_emergencymotorType eps_st_emergencymotor;
    
    ::Eps_st_emergencyecuType eps_st_emergencyecu;
    
    ::Eps_st_emergencycaninterfaceType eps_st_emergencycaninterface;
    
    ::Eps_st_emergencysensorType eps_st_emergencysensor;
    
    ::Eps_st_emergencyovertempType eps_st_emergencyovertemp;
    
    ::Eps_st_emergencyovervoltageType eps_st_emergencyovervoltage;
    
    ::Eps_st_emergencyundervoltageType eps_st_emergencyundervoltage;
    
    ::Eps_f_ecutempvalidType eps_f_ecutempvalid;
    
    ::Eps_sassoftlimitleftflgType eps_sassoftlimitleftflg;
    
    ::Int32 eps_n_ecutemp;
    
    ::Double eps_n_performanceredu;
    
    ::Eps_st_dtcflagType eps_st_dtcflag;
    
    ::Int32 rolling_counter_0x260;
    
    ::Eps_sasindexstsType eps_sasindexsts;
    
    ::Eps_s_warninglampyellowType eps_s_warninglampyellow;
    
    ::Int32 checksum_0x260;
    
    ::Eps_s_safelampredType eps_s_safelampred;
    
    ::Eps_f_loadinfoType eps_f_loadinfo;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(eps_n_loadinfo);
        fun(eps_sassoftlimitrightflg);
        fun(eps_st_emergencypowerlimit);
        fun(eps_st_emergencymotor);
        fun(eps_st_emergencyecu);
        fun(eps_st_emergencycaninterface);
        fun(eps_st_emergencysensor);
        fun(eps_st_emergencyovertemp);
        fun(eps_st_emergencyovervoltage);
        fun(eps_st_emergencyundervoltage);
        fun(eps_f_ecutempvalid);
        fun(eps_sassoftlimitleftflg);
        fun(eps_n_ecutemp);
        fun(eps_n_performanceredu);
        fun(eps_st_dtcflag);
        fun(rolling_counter_0x260);
        fun(eps_sasindexsts);
        fun(eps_s_warninglampyellow);
        fun(checksum_0x260);
        fun(eps_s_safelampred);
        fun(eps_f_loadinfo);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(eps_n_loadinfo);
        fun(eps_sassoftlimitrightflg);
        fun(eps_st_emergencypowerlimit);
        fun(eps_st_emergencymotor);
        fun(eps_st_emergencyecu);
        fun(eps_st_emergencycaninterface);
        fun(eps_st_emergencysensor);
        fun(eps_st_emergencyovertemp);
        fun(eps_st_emergencyovervoltage);
        fun(eps_st_emergencyundervoltage);
        fun(eps_f_ecutempvalid);
        fun(eps_sassoftlimitleftflg);
        fun(eps_n_ecutemp);
        fun(eps_n_performanceredu);
        fun(eps_st_dtcflag);
        fun(rolling_counter_0x260);
        fun(eps_sasindexsts);
        fun(eps_s_warninglampyellow);
        fun(checksum_0x260);
        fun(eps_s_safelampred);
        fun(eps_f_loadinfo);
    }

    bool operator == (const ::Eps_0x260_260& t) const {
        return (eps_n_loadinfo == t.eps_n_loadinfo) && (eps_sassoftlimitrightflg == t.eps_sassoftlimitrightflg) && (eps_st_emergencypowerlimit == t.eps_st_emergencypowerlimit) && (eps_st_emergencymotor == t.eps_st_emergencymotor) && (eps_st_emergencyecu == t.eps_st_emergencyecu) && (eps_st_emergencycaninterface == t.eps_st_emergencycaninterface) && (eps_st_emergencysensor == t.eps_st_emergencysensor) && (eps_st_emergencyovertemp == t.eps_st_emergencyovertemp) && (eps_st_emergencyovervoltage == t.eps_st_emergencyovervoltage) && (eps_st_emergencyundervoltage == t.eps_st_emergencyundervoltage) && (eps_f_ecutempvalid == t.eps_f_ecutempvalid) && (eps_sassoftlimitleftflg == t.eps_sassoftlimitleftflg) && (eps_n_ecutemp == t.eps_n_ecutemp) && (eps_n_performanceredu == t.eps_n_performanceredu) && (eps_st_dtcflag == t.eps_st_dtcflag) && (rolling_counter_0x260 == t.rolling_counter_0x260) && (eps_sasindexsts == t.eps_sasindexsts) && (eps_s_warninglampyellow == t.eps_s_warninglampyellow) && (checksum_0x260 == t.checksum_0x260) && (eps_s_safelampred == t.eps_s_safelampred) && (eps_f_loadinfo == t.eps_f_loadinfo);
    }
};


#endif // impl_type_eps_0x260_260_h
