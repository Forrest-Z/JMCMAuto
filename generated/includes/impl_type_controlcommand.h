/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_controlcommand_h
#define impl_type_controlcommand_h





















#include "impl_type_bool.h"
#include "impl_type_latencystats.h"
#include "impl_type_gearposition.h"
#include "impl_type_double.h"
#include "impl_type_turnsignal.h"
#include "impl_type_int32.h"
#include "impl_type_padmessage.h"
#include "impl_type_header.h"
#include "impl_type_drivingmode.h"
#include "impl_type_engageadvice.h"
#include "impl_type_debug.h"
#include "impl_type_vehiclesignal.h"


struct ControlCommand {
    ::Header header;
    
    ::Double steering_target;
    
    ::Bool parking_brake;
    
    ::Double speed;
    
    ::Double acceleration;
    
    ::Bool reset_model;
    
    ::Bool engine_on_off;
    
    ::Double trajectory_fraction;
    
    ::DrivingMode driving_mode;
    
    ::GearPosition gear_location;
    
    ::Debug debug;
    
    ::VehicleSignal signal;
    
    ::LatencyStats latency_stats;
    
    ::PadMessage pad_msg;
    
    ::EngageAdvice engage_advice;
    
    ::Bool is_in_safe_mode;
    
    ::Double steering_torque;
    
    ::Int32 pam_esp_stop_distance;
    
    ::Bool ACC_StandstillReq;
    
    ::TurnSignal TurnSignal;
    

    static bool IsPlane()
    {
        return false;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(header);
        fun(steering_target);
        fun(parking_brake);
        fun(speed);
        fun(acceleration);
        fun(reset_model);
        fun(engine_on_off);
        fun(trajectory_fraction);
        fun(driving_mode);
        fun(gear_location);
        fun(debug);
        fun(signal);
        fun(latency_stats);
        fun(pad_msg);
        fun(engage_advice);
        fun(is_in_safe_mode);
        fun(steering_torque);
        fun(pam_esp_stop_distance);
        fun(ACC_StandstillReq);
        fun(TurnSignal);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(header);
        fun(steering_target);
        fun(parking_brake);
        fun(speed);
        fun(acceleration);
        fun(reset_model);
        fun(engine_on_off);
        fun(trajectory_fraction);
        fun(driving_mode);
        fun(gear_location);
        fun(debug);
        fun(signal);
        fun(latency_stats);
        fun(pad_msg);
        fun(engage_advice);
        fun(is_in_safe_mode);
        fun(steering_torque);
        fun(pam_esp_stop_distance);
        fun(ACC_StandstillReq);
        fun(TurnSignal);
    }

    bool operator == (const ::ControlCommand& t) const {
        return (header == t.header) && (steering_target == t.steering_target) && (parking_brake == t.parking_brake) && (speed == t.speed) && (acceleration == t.acceleration) && (reset_model == t.reset_model) && (engine_on_off == t.engine_on_off) && (trajectory_fraction == t.trajectory_fraction) && (driving_mode == t.driving_mode) && (gear_location == t.gear_location) && (debug == t.debug) && (signal == t.signal) && (latency_stats == t.latency_stats) && (pad_msg == t.pad_msg) && (engage_advice == t.engage_advice) && (is_in_safe_mode == t.is_in_safe_mode) && (steering_torque == t.steering_torque) && (pam_esp_stop_distance == t.pam_esp_stop_distance) && (ACC_StandstillReq == t.ACC_StandstillReq) && (TurnSignal == t.TurnSignal);
    }
};


#endif // impl_type_controlcommand_h
