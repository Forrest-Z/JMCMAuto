/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_simplelateraldebug_h
#define impl_type_simplelateraldebug_h
























#include "impl_type_double.h"


struct SimpleLateralDebug {
    ::Double lateral_error;
    
    ::Double lateral_error_rate;
    
    ::Double heading_error;
    
    ::Double heading_error_rate;
    
    ::Double ref_heading;
    
    ::Double heading;
    
    ::Double curvature;
    
    ::Double steer_angle;
    
    ::Double steer_angle_feedforward;
    
    ::Double steer_angle_feedback;
    
    ::Double steer_angle_lateral_contribution;
    
    ::Double steer_angle_lateral_rate_contribution;
    
    ::Double steer_angle_heading_contribution;
    
    ::Double steer_angle_heading_rate_contribution;
    
    ::Double steering_position;
    
    ::Double ref_speed;
    
    ::Double steer_angle_limited;
    
    ::Double steer_targe_position_error;
    
    ::Double steering_torque;
    
    ::Double lateral_acceleration;
    
    ::Double lateral_jerk;
    
    ::Double ref_heading_rate;
    
    ::Double heading_rate;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(lateral_error);
        fun(lateral_error_rate);
        fun(heading_error);
        fun(heading_error_rate);
        fun(ref_heading);
        fun(heading);
        fun(curvature);
        fun(steer_angle);
        fun(steer_angle_feedforward);
        fun(steer_angle_feedback);
        fun(steer_angle_lateral_contribution);
        fun(steer_angle_lateral_rate_contribution);
        fun(steer_angle_heading_contribution);
        fun(steer_angle_heading_rate_contribution);
        fun(steering_position);
        fun(ref_speed);
        fun(steer_angle_limited);
        fun(steer_targe_position_error);
        fun(steering_torque);
        fun(lateral_acceleration);
        fun(lateral_jerk);
        fun(ref_heading_rate);
        fun(heading_rate);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(lateral_error);
        fun(lateral_error_rate);
        fun(heading_error);
        fun(heading_error_rate);
        fun(ref_heading);
        fun(heading);
        fun(curvature);
        fun(steer_angle);
        fun(steer_angle_feedforward);
        fun(steer_angle_feedback);
        fun(steer_angle_lateral_contribution);
        fun(steer_angle_lateral_rate_contribution);
        fun(steer_angle_heading_contribution);
        fun(steer_angle_heading_rate_contribution);
        fun(steering_position);
        fun(ref_speed);
        fun(steer_angle_limited);
        fun(steer_targe_position_error);
        fun(steering_torque);
        fun(lateral_acceleration);
        fun(lateral_jerk);
        fun(ref_heading_rate);
        fun(heading_rate);
    }

    bool operator == (const ::SimpleLateralDebug& t) const {
        return (lateral_error == t.lateral_error) && (lateral_error_rate == t.lateral_error_rate) && (heading_error == t.heading_error) && (heading_error_rate == t.heading_error_rate) && (ref_heading == t.ref_heading) && (heading == t.heading) && (curvature == t.curvature) && (steer_angle == t.steer_angle) && (steer_angle_feedforward == t.steer_angle_feedforward) && (steer_angle_feedback == t.steer_angle_feedback) && (steer_angle_lateral_contribution == t.steer_angle_lateral_contribution) && (steer_angle_lateral_rate_contribution == t.steer_angle_lateral_rate_contribution) && (steer_angle_heading_contribution == t.steer_angle_heading_contribution) && (steer_angle_heading_rate_contribution == t.steer_angle_heading_rate_contribution) && (steering_position == t.steering_position) && (ref_speed == t.ref_speed) && (steer_angle_limited == t.steer_angle_limited) && (steer_targe_position_error == t.steer_targe_position_error) && (steering_torque == t.steering_torque) && (lateral_acceleration == t.lateral_acceleration) && (lateral_jerk == t.lateral_jerk) && (ref_heading_rate == t.ref_heading_rate) && (heading_rate == t.heading_rate);
    }
};


#endif // impl_type_simplelateraldebug_h
