/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_esp_status_0x243_243_h
#define impl_type_esp_status_0x243_243_h




























#include "impl_type_esp_epbwarningmessage3type.h"
#include "impl_type_esp_epberrorstatustype.h"
#include "impl_type_esp_driving_mode_reqtype.h"
#include "impl_type_esp_avhstandbytype.h"
#include "impl_type_esp_espinfolamptype.h"
#include "impl_type_esp_gearshiftprevntype.h"
#include "impl_type_esp_ccswitchofftype.h"
#include "impl_type_esp_ldmblc_blrequestcontrollertype.h"
#include "impl_type_esp_tcsctrlactvtype.h"
#include "impl_type_esp_cdpavailabletype.h"
#include "impl_type_esp_epbstatustype.h"
#include "impl_type_esp_avhwarningmessagetype.h"
#include "impl_type_esp_espctrlactvtype.h"
#include "impl_type_esp_espenableststype.h"
#include "impl_type_esp_hhcavailabletype.h"
#include "impl_type_rollerbenchmodeststype.h"
#include "impl_type_esp_hhcactivetype.h"
#include "impl_type_esp_vdcflgflttype.h"
#include "impl_type_esp_epbwarningmessage2type.h"
#include "impl_type_int32.h"
#include "impl_type_esp_tcsflgflttype.h"
#include "impl_type_esp_avhactivetype.h"
#include "impl_type_esp_avhavabliabletype.h"
#include "impl_type_esp_epbwarningmessage1type.h"
#include "impl_type_esp_hdcavailabletype.h"


struct Esp_status_0x243_243 {
    ::Esp_hhcavailableType esp_hhcavailable;
    
    ::Esp_hhcactiveType esp_hhcactive;
    
    ::Esp_hdcavailableType esp_hdcactive;
    
    ::Esp_ldmblc_blrequestcontrollerType esp_ldmblc_blrequestcontroller;
    
    ::Esp_cdpavailableType esp_cdpavailable;
    
    ::Esp_epbwarningmessage3Type esp_epbwarningmessage3;
    
    ::Esp_epbwarningmessage2Type esp_epbwarningmessage2;
    
    ::Esp_epbwarningmessage1Type esp_epbwarningmessage1;
    
    ::Esp_avhwarningmessageType esp_avhwarningmessage;
    
    ::Esp_avhactiveType esp_avhactive;
    
    ::Esp_avhstandbyType esp_avhstandby;
    
    ::Esp_avhavabliableType esp_avhavabliable;
    
    ::Esp_vdcflgfltType esp_vdcflgflt;
    
    ::Esp_tcsflgfltType esp_tcsflgflt;
    
    ::Esp_tcsctrlactvType esp_tcsctrlactv;
    
    ::Esp_espctrlactvType esp_espctrlactv;
    
    ::Esp_driving_mode_reqType esp_driving_mode_req;
    
    ::Esp_espinfolampType esp_espinfolamp;
    
    ::Esp_espenablestsType esp_espenablests;
    
    ::Esp_gearshiftprevnType esp_gearshiftprevn;
    
    ::Esp_epbstatusType esp_epbstatus;
    
    ::Int32 rollingcounter_0x243;
    
    ::RollerbenchmodestsType rollerbenchmodests;
    
    ::Int32 checksum_0x243;
    
    ::Esp_epberrorstatusType esp_epberrorstatus;
    
    ::Esp_ccswitchoffType esp_ccswitchoff;
    
    ::Esp_hdcavailableType esp_hdcavailable;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(esp_hhcavailable);
        fun(esp_hhcactive);
        fun(esp_hdcactive);
        fun(esp_ldmblc_blrequestcontroller);
        fun(esp_cdpavailable);
        fun(esp_epbwarningmessage3);
        fun(esp_epbwarningmessage2);
        fun(esp_epbwarningmessage1);
        fun(esp_avhwarningmessage);
        fun(esp_avhactive);
        fun(esp_avhstandby);
        fun(esp_avhavabliable);
        fun(esp_vdcflgflt);
        fun(esp_tcsflgflt);
        fun(esp_tcsctrlactv);
        fun(esp_espctrlactv);
        fun(esp_driving_mode_req);
        fun(esp_espinfolamp);
        fun(esp_espenablests);
        fun(esp_gearshiftprevn);
        fun(esp_epbstatus);
        fun(rollingcounter_0x243);
        fun(rollerbenchmodests);
        fun(checksum_0x243);
        fun(esp_epberrorstatus);
        fun(esp_ccswitchoff);
        fun(esp_hdcavailable);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(esp_hhcavailable);
        fun(esp_hhcactive);
        fun(esp_hdcactive);
        fun(esp_ldmblc_blrequestcontroller);
        fun(esp_cdpavailable);
        fun(esp_epbwarningmessage3);
        fun(esp_epbwarningmessage2);
        fun(esp_epbwarningmessage1);
        fun(esp_avhwarningmessage);
        fun(esp_avhactive);
        fun(esp_avhstandby);
        fun(esp_avhavabliable);
        fun(esp_vdcflgflt);
        fun(esp_tcsflgflt);
        fun(esp_tcsctrlactv);
        fun(esp_espctrlactv);
        fun(esp_driving_mode_req);
        fun(esp_espinfolamp);
        fun(esp_espenablests);
        fun(esp_gearshiftprevn);
        fun(esp_epbstatus);
        fun(rollingcounter_0x243);
        fun(rollerbenchmodests);
        fun(checksum_0x243);
        fun(esp_epberrorstatus);
        fun(esp_ccswitchoff);
        fun(esp_hdcavailable);
    }

    bool operator == (const ::Esp_status_0x243_243& t) const {
        return (esp_hhcavailable == t.esp_hhcavailable) && (esp_hhcactive == t.esp_hhcactive) && (esp_hdcactive == t.esp_hdcactive) && (esp_ldmblc_blrequestcontroller == t.esp_ldmblc_blrequestcontroller) && (esp_cdpavailable == t.esp_cdpavailable) && (esp_epbwarningmessage3 == t.esp_epbwarningmessage3) && (esp_epbwarningmessage2 == t.esp_epbwarningmessage2) && (esp_epbwarningmessage1 == t.esp_epbwarningmessage1) && (esp_avhwarningmessage == t.esp_avhwarningmessage) && (esp_avhactive == t.esp_avhactive) && (esp_avhstandby == t.esp_avhstandby) && (esp_avhavabliable == t.esp_avhavabliable) && (esp_vdcflgflt == t.esp_vdcflgflt) && (esp_tcsflgflt == t.esp_tcsflgflt) && (esp_tcsctrlactv == t.esp_tcsctrlactv) && (esp_espctrlactv == t.esp_espctrlactv) && (esp_driving_mode_req == t.esp_driving_mode_req) && (esp_espinfolamp == t.esp_espinfolamp) && (esp_espenablests == t.esp_espenablests) && (esp_gearshiftprevn == t.esp_gearshiftprevn) && (esp_epbstatus == t.esp_epbstatus) && (rollingcounter_0x243 == t.rollingcounter_0x243) && (rollerbenchmodests == t.rollerbenchmodests) && (checksum_0x243 == t.checksum_0x243) && (esp_epberrorstatus == t.esp_epberrorstatus) && (esp_ccswitchoff == t.esp_ccswitchoff) && (esp_hdcavailable == t.esp_hdcavailable);
    }
};


#endif // impl_type_esp_status_0x243_243_h
