/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_esp_rpmf_0x213_213_h
#define impl_type_esp_rpmf_0x213_213_h







#include "impl_type_double.h"
#include "impl_type_esp_wheelrpmfrvalidtype.h"
#include "impl_type_int32.h"
#include "impl_type_esp_vxwwheelflvalidtype.h"


struct Esp_rpmf_0x213_213 {
    ::Double esp_wheelrpmfr;
    
    ::Esp_wheelrpmfrvalidType esp_wheelrpmfrvalid;
    
    ::Int32 rolling_counter_0x213;
    
    ::Int32 checksum_0x213;
    
    ::Double esp_wheelrpmfl;
    
    ::Esp_vxwwheelflvalidType esp_wheelrpmflvalid;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(esp_wheelrpmfr);
        fun(esp_wheelrpmfrvalid);
        fun(rolling_counter_0x213);
        fun(checksum_0x213);
        fun(esp_wheelrpmfl);
        fun(esp_wheelrpmflvalid);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(esp_wheelrpmfr);
        fun(esp_wheelrpmfrvalid);
        fun(rolling_counter_0x213);
        fun(checksum_0x213);
        fun(esp_wheelrpmfl);
        fun(esp_wheelrpmflvalid);
    }

    bool operator == (const ::Esp_rpmf_0x213_213& t) const {
        return (esp_wheelrpmfr == t.esp_wheelrpmfr) && (esp_wheelrpmfrvalid == t.esp_wheelrpmfrvalid) && (rolling_counter_0x213 == t.rolling_counter_0x213) && (checksum_0x213 == t.checksum_0x213) && (esp_wheelrpmfl == t.esp_wheelrpmfl) && (esp_wheelrpmflvalid == t.esp_wheelrpmflvalid);
    }
};


#endif // impl_type_esp_rpmf_0x213_213_h
