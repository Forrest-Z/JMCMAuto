/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_gas_h
#define impl_type_gas_h





















#include "impl_type_double.h"
#include "impl_type_bool.h"
#include "impl_type_int32.h"


struct Gas {
    ::Bool is_gas_pedal_error;
    
    ::Bool is_gas_pedal_pressed_more;
    
    ::Double gas_pedal_position;
    
    ::Bool is_gas_valid;
    
    ::Double throttle_input;
    
    ::Double throttle_cmd;
    
    ::Double throttle_output;
    
    ::Int32 watchdog_source;
    
    ::Bool throttle_enabled;
    
    ::Bool driver_override;
    
    ::Bool driver_activity;
    
    ::Bool watchdog_fault;
    
    ::Bool channel_1_fault;
    
    ::Bool channel_2_fault;
    
    ::Bool connector_fault;
    
    ::Double accelerator_pedal;
    
    ::Double accelerator_pedal_rate;
    
    ::Int32 major_version;
    
    ::Int32 minor_version;
    
    ::Int32 build_number;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(is_gas_pedal_error);
        fun(is_gas_pedal_pressed_more);
        fun(gas_pedal_position);
        fun(is_gas_valid);
        fun(throttle_input);
        fun(throttle_cmd);
        fun(throttle_output);
        fun(watchdog_source);
        fun(throttle_enabled);
        fun(driver_override);
        fun(driver_activity);
        fun(watchdog_fault);
        fun(channel_1_fault);
        fun(channel_2_fault);
        fun(connector_fault);
        fun(accelerator_pedal);
        fun(accelerator_pedal_rate);
        fun(major_version);
        fun(minor_version);
        fun(build_number);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(is_gas_pedal_error);
        fun(is_gas_pedal_pressed_more);
        fun(gas_pedal_position);
        fun(is_gas_valid);
        fun(throttle_input);
        fun(throttle_cmd);
        fun(throttle_output);
        fun(watchdog_source);
        fun(throttle_enabled);
        fun(driver_override);
        fun(driver_activity);
        fun(watchdog_fault);
        fun(channel_1_fault);
        fun(channel_2_fault);
        fun(connector_fault);
        fun(accelerator_pedal);
        fun(accelerator_pedal_rate);
        fun(major_version);
        fun(minor_version);
        fun(build_number);
    }

    bool operator == (const ::Gas& t) const {
        return (is_gas_pedal_error == t.is_gas_pedal_error) && (is_gas_pedal_pressed_more == t.is_gas_pedal_pressed_more) && (gas_pedal_position == t.gas_pedal_position) && (is_gas_valid == t.is_gas_valid) && (throttle_input == t.throttle_input) && (throttle_cmd == t.throttle_cmd) && (throttle_output == t.throttle_output) && (watchdog_source == t.watchdog_source) && (throttle_enabled == t.throttle_enabled) && (driver_override == t.driver_override) && (driver_activity == t.driver_activity) && (watchdog_fault == t.watchdog_fault) && (channel_1_fault == t.channel_1_fault) && (channel_2_fault == t.channel_2_fault) && (connector_fault == t.connector_fault) && (accelerator_pedal == t.accelerator_pedal) && (accelerator_pedal_rate == t.accelerator_pedal_rate) && (major_version == t.major_version) && (minor_version == t.minor_version) && (build_number == t.build_number);
    }
};


#endif // impl_type_gas_h
