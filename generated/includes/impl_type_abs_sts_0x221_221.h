/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_abs_sts_0x221_221_h
#define impl_type_abs_sts_0x221_221_h













#include "impl_type_double.h"
#include "impl_type_abs_whlmilgfrntristatustype.h"
#include "impl_type_abs_vehspdlgtstatustype.h"
#include "impl_type_int32.h"
#include "impl_type_abs_absflgflttype.h"
#include "impl_type_abs_absctrlactvtype.h"
#include "impl_type_abs_vehspddirectiontype.h"
#include "impl_type_abs_ebdflgflttype.h"
#include "impl_type_abs_whlmilgfrntlestatustype.h"


struct Abs_sts_0x221_221 {
    ::Int32 abs_whlmilgfrntri;
    
    ::Double abs_vehspdlgt;
    
    ::Abs_vehspddirectionType abs_vehspddirection;
    
    ::Abs_ebdflgfltType abs_ebdflgflt;
    
    ::Abs_absflgfltType abs_absflgflt;
    
    ::Abs_absctrlactvType abs_absctrlactv;
    
    ::Int32 rollingcounter_0x221;
    
    ::Abs_whlmilgfrntlestatusType abs_whlmilgfrntlestatus;
    
    ::Abs_whlmilgfrntristatusType abs_whlmilgfrntristatus;
    
    ::Abs_vehspdlgtstatusType abs_vehspdlgtstatus;
    
    ::Int32 checksum_0x221;
    
    ::Int32 abs_whlmilgfrntle;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(abs_whlmilgfrntri);
        fun(abs_vehspdlgt);
        fun(abs_vehspddirection);
        fun(abs_ebdflgflt);
        fun(abs_absflgflt);
        fun(abs_absctrlactv);
        fun(rollingcounter_0x221);
        fun(abs_whlmilgfrntlestatus);
        fun(abs_whlmilgfrntristatus);
        fun(abs_vehspdlgtstatus);
        fun(checksum_0x221);
        fun(abs_whlmilgfrntle);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(abs_whlmilgfrntri);
        fun(abs_vehspdlgt);
        fun(abs_vehspddirection);
        fun(abs_ebdflgflt);
        fun(abs_absflgflt);
        fun(abs_absctrlactv);
        fun(rollingcounter_0x221);
        fun(abs_whlmilgfrntlestatus);
        fun(abs_whlmilgfrntristatus);
        fun(abs_vehspdlgtstatus);
        fun(checksum_0x221);
        fun(abs_whlmilgfrntle);
    }

    bool operator == (const ::Abs_sts_0x221_221& t) const {
        return (abs_whlmilgfrntri == t.abs_whlmilgfrntri) && (abs_vehspdlgt == t.abs_vehspdlgt) && (abs_vehspddirection == t.abs_vehspddirection) && (abs_ebdflgflt == t.abs_ebdflgflt) && (abs_absflgflt == t.abs_absflgflt) && (abs_absctrlactv == t.abs_absctrlactv) && (rollingcounter_0x221 == t.rollingcounter_0x221) && (abs_whlmilgfrntlestatus == t.abs_whlmilgfrntlestatus) && (abs_whlmilgfrntristatus == t.abs_whlmilgfrntristatus) && (abs_vehspdlgtstatus == t.abs_vehspdlgtstatus) && (checksum_0x221 == t.checksum_0x221) && (abs_whlmilgfrntle == t.abs_whlmilgfrntle);
    }
};


#endif // impl_type_abs_sts_0x221_221_h
