/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_ipm_leftline_0x278_278_h
#define impl_type_ipm_leftline_0x278_278_h






#include "impl_type_double.h"


struct Ipm_leftline_0x278_278 {
    ::Double ipm_leftline_dy;
    
    ::Double ipm_leftline_dx_lookhead;
    
    ::Double ipm_leftline_hor_curve;
    
    ::Double ipm_leftline_yawangle;
    
    ::Double ipm_ledtline_dx_start;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(ipm_leftline_dy);
        fun(ipm_leftline_dx_lookhead);
        fun(ipm_leftline_hor_curve);
        fun(ipm_leftline_yawangle);
        fun(ipm_ledtline_dx_start);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(ipm_leftline_dy);
        fun(ipm_leftline_dx_lookhead);
        fun(ipm_leftline_hor_curve);
        fun(ipm_leftline_yawangle);
        fun(ipm_ledtline_dx_start);
    }

    bool operator == (const ::Ipm_leftline_0x278_278& t) const {
        return (ipm_leftline_dy == t.ipm_leftline_dy) && (ipm_leftline_dx_lookhead == t.ipm_leftline_dx_lookhead) && (ipm_leftline_hor_curve == t.ipm_leftline_hor_curve) && (ipm_leftline_yawangle == t.ipm_leftline_yawangle) && (ipm_ledtline_dx_start == t.ipm_ledtline_dx_start);
    }
};


#endif // impl_type_ipm_leftline_0x278_278_h
