/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_global_rpt_6a_h
#define impl_type_global_rpt_6a_h








#include "impl_type_override_statustype.h"
#include "impl_type_pacmod_statustype.h"
#include "impl_type_bool.h"
#include "impl_type_int32.h"
#include "impl_type_brk_can_timeouttype.h"


struct Global_rpt_6a {
    ::Pacmod_statusType pacmod_status;
    
    ::Override_statusType override_status;
    
    ::Bool veh_can_timeout;
    
    ::Bool str_can_timeout;
    
    ::Bool usr_can_timeout;
    
    ::Brk_can_timeoutType brk_can_timeout;
    
    ::Int32 usr_can_read_errors;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(pacmod_status);
        fun(override_status);
        fun(veh_can_timeout);
        fun(str_can_timeout);
        fun(usr_can_timeout);
        fun(brk_can_timeout);
        fun(usr_can_read_errors);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(pacmod_status);
        fun(override_status);
        fun(veh_can_timeout);
        fun(str_can_timeout);
        fun(usr_can_timeout);
        fun(brk_can_timeout);
        fun(usr_can_read_errors);
    }

    bool operator == (const ::Global_rpt_6a& t) const {
        return (pacmod_status == t.pacmod_status) && (override_status == t.override_status) && (veh_can_timeout == t.veh_can_timeout) && (str_can_timeout == t.str_can_timeout) && (usr_can_timeout == t.usr_can_timeout) && (brk_can_timeout == t.brk_can_timeout) && (usr_can_read_errors == t.usr_can_read_errors);
    }
};


#endif // impl_type_global_rpt_6a_h
