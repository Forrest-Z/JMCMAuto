/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_eps_h
#define impl_type_eps_h


























#include "impl_type_double.h"
#include "impl_type_bool.h"
#include "impl_type_epstype.h"
#include "impl_type_int32.h"


struct Eps {
    ::Bool is_eps_fail;
    
    ::EpsType eps_control_state;
    
    ::Double eps_driver_hand_torq;
    
    ::Bool is_steering_angle_valid;
    
    ::Double steering_angle;
    
    ::Double steering_angle_spd;
    
    ::Bool is_trimming_status;
    
    ::Bool is_calibration_status;
    
    ::Bool is_failure_status;
    
    ::Int32 allow_enter_autonomous_mode;
    
    ::Int32 current_driving_mode;
    
    ::Double steering_angle_cmd;
    
    ::Double vehicle_speed;
    
    ::Double epas_torque;
    
    ::Bool steering_enabled;
    
    ::Bool driver_activity;
    
    ::Bool watchdog_fault;
    
    ::Bool channel_1_fault;
    
    ::Bool channel_2_fault;
    
    ::Bool calibration_fault;
    
    ::Bool connector_fault;
    
    ::Double timestamp_65;
    
    ::Int32 major_version;
    
    ::Int32 minor_version;
    
    ::Int32 build_number;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(is_eps_fail);
        fun(eps_control_state);
        fun(eps_driver_hand_torq);
        fun(is_steering_angle_valid);
        fun(steering_angle);
        fun(steering_angle_spd);
        fun(is_trimming_status);
        fun(is_calibration_status);
        fun(is_failure_status);
        fun(allow_enter_autonomous_mode);
        fun(current_driving_mode);
        fun(steering_angle_cmd);
        fun(vehicle_speed);
        fun(epas_torque);
        fun(steering_enabled);
        fun(driver_activity);
        fun(watchdog_fault);
        fun(channel_1_fault);
        fun(channel_2_fault);
        fun(calibration_fault);
        fun(connector_fault);
        fun(timestamp_65);
        fun(major_version);
        fun(minor_version);
        fun(build_number);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(is_eps_fail);
        fun(eps_control_state);
        fun(eps_driver_hand_torq);
        fun(is_steering_angle_valid);
        fun(steering_angle);
        fun(steering_angle_spd);
        fun(is_trimming_status);
        fun(is_calibration_status);
        fun(is_failure_status);
        fun(allow_enter_autonomous_mode);
        fun(current_driving_mode);
        fun(steering_angle_cmd);
        fun(vehicle_speed);
        fun(epas_torque);
        fun(steering_enabled);
        fun(driver_activity);
        fun(watchdog_fault);
        fun(channel_1_fault);
        fun(channel_2_fault);
        fun(calibration_fault);
        fun(connector_fault);
        fun(timestamp_65);
        fun(major_version);
        fun(minor_version);
        fun(build_number);
    }

    bool operator == (const ::Eps& t) const {
        return (is_eps_fail == t.is_eps_fail) && (eps_control_state == t.eps_control_state) && (eps_driver_hand_torq == t.eps_driver_hand_torq) && (is_steering_angle_valid == t.is_steering_angle_valid) && (steering_angle == t.steering_angle) && (steering_angle_spd == t.steering_angle_spd) && (is_trimming_status == t.is_trimming_status) && (is_calibration_status == t.is_calibration_status) && (is_failure_status == t.is_failure_status) && (allow_enter_autonomous_mode == t.allow_enter_autonomous_mode) && (current_driving_mode == t.current_driving_mode) && (steering_angle_cmd == t.steering_angle_cmd) && (vehicle_speed == t.vehicle_speed) && (epas_torque == t.epas_torque) && (steering_enabled == t.steering_enabled) && (driver_activity == t.driver_activity) && (watchdog_fault == t.watchdog_fault) && (channel_1_fault == t.channel_1_fault) && (channel_2_fault == t.channel_2_fault) && (calibration_fault == t.calibration_fault) && (connector_fault == t.connector_fault) && (timestamp_65 == t.timestamp_65) && (major_version == t.major_version) && (minor_version == t.minor_version) && (build_number == t.build_number);
    }
};


#endif // impl_type_eps_h
