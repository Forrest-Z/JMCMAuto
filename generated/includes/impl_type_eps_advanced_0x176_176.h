/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_eps_advanced_0x176_176_h
#define impl_type_eps_advanced_0x176_176_h












#include "impl_type_double.h"
#include "impl_type_eps_lkaresponsetorquevalidtype.h"
#include "impl_type_int32.h"
#include "impl_type_eps_epspaminhtype.h"
#include "impl_type_eps_tosionbartorquevalidtype.h"
#include "impl_type_eps_pam_steeringsts_reservedtype.h"
#include "impl_type_eps_epspamststype.h"
#include "impl_type_eps_ldwcontrolstatustype.h"
#include "impl_type_eps_lkacontrolstatustype.h"


struct Eps_advanced_0x176_176 {
    ::Double eps_lkaresponsetorque;
    
    ::Eps_tosionbartorquevalidType eps_tosionbartorquevalid;
    
    ::Eps_lkaresponsetorquevalidType eps_lkaresponsetorquevalid;
    
    ::Eps_ldwcontrolstatusType eps_ldwcontrolstatus;
    
    ::Eps_pam_steeringsts_reservedType eps_pam_steeringsts_reserved;
    
    ::Eps_lkacontrolstatusType eps_lkacontrolstatus;
    
    ::Eps_epspaminhType eps_epspaminh;
    
    ::Int32 rolling_counter_0x176;
    
    ::Eps_epspamstsType eps_epspamsts;
    
    ::Int32 checksum_0x176;
    
    ::Double eps_torsionbartorque;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(eps_lkaresponsetorque);
        fun(eps_tosionbartorquevalid);
        fun(eps_lkaresponsetorquevalid);
        fun(eps_ldwcontrolstatus);
        fun(eps_pam_steeringsts_reserved);
        fun(eps_lkacontrolstatus);
        fun(eps_epspaminh);
        fun(rolling_counter_0x176);
        fun(eps_epspamsts);
        fun(checksum_0x176);
        fun(eps_torsionbartorque);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(eps_lkaresponsetorque);
        fun(eps_tosionbartorquevalid);
        fun(eps_lkaresponsetorquevalid);
        fun(eps_ldwcontrolstatus);
        fun(eps_pam_steeringsts_reserved);
        fun(eps_lkacontrolstatus);
        fun(eps_epspaminh);
        fun(rolling_counter_0x176);
        fun(eps_epspamsts);
        fun(checksum_0x176);
        fun(eps_torsionbartorque);
    }

    bool operator == (const ::Eps_advanced_0x176_176& t) const {
        return (eps_lkaresponsetorque == t.eps_lkaresponsetorque) && (eps_tosionbartorquevalid == t.eps_tosionbartorquevalid) && (eps_lkaresponsetorquevalid == t.eps_lkaresponsetorquevalid) && (eps_ldwcontrolstatus == t.eps_ldwcontrolstatus) && (eps_pam_steeringsts_reserved == t.eps_pam_steeringsts_reserved) && (eps_lkacontrolstatus == t.eps_lkacontrolstatus) && (eps_epspaminh == t.eps_epspaminh) && (rolling_counter_0x176 == t.rolling_counter_0x176) && (eps_epspamsts == t.eps_epspamsts) && (checksum_0x176 == t.checksum_0x176) && (eps_torsionbartorque == t.eps_torsionbartorque);
    }
};


#endif // impl_type_eps_advanced_0x176_176_h
