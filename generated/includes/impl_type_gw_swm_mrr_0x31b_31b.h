/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_gw_swm_mrr_0x31b_31b_h
#define impl_type_gw_swm_mrr_0x31b_31b_h

















#include "impl_type_swm_acclimphomeststype.h"
#include "impl_type_swm_accenableswitchtype.h"
#include "impl_type_swm_accvsetplustype.h"
#include "impl_type_swm_acctaugapsetplustype.h"
#include "impl_type_swm_shiftpadflttype.h"
#include "impl_type_swm_shiftpadrequptype.h"
#include "impl_type_swm_accvsetminustype.h"
#include "impl_type_swm_acctaugapsetminustype.h"
#include "impl_type_swm_accresumetype.h"
#include "impl_type_int32.h"
#include "impl_type_swm_accdeactivatetype.h"
#include "impl_type_swm_tjaswitchtype.h"
#include "impl_type_swm_laneassistswitchtype.h"
#include "impl_type_swm_shiftpadreqdowntype.h"
#include "impl_type_swm_accresume_qttype.h"


struct Gw_swm_mrr_0x31b_31b {
    ::Swm_acctaugapsetplusType swm_acctaugapsetplus;
    
    ::Swm_accvsetminusType swm_accvsetminus;
    
    ::Swm_shiftpadrequpType swm_shiftpadrequp;
    
    ::Swm_acclimphomestsType swm_acclimphomests;
    
    ::Swm_laneassistswitchType swm_laneassistswitch;
    
    ::Swm_acctaugapsetminusType swm_acctaugapsetminus;
    
    ::Swm_accvsetplusType swm_accvsetplus;
    
    ::Swm_shiftpadfltType swm_shiftpadflt;
    
    ::Swm_accdeactivateType swm_accdeactivate;
    
    ::Swm_accresumeType swm_accresume;
    
    ::Int32 rolling_counter_0x31b;
    
    ::Swm_accenableswitchType swm_accenableswitch;
    
    ::Int32 checksum_0x31b;
    
    ::Swm_accresume_qtType swm_accresume_qt;
    
    ::Swm_tjaswitchType swm_tjaswitch;
    
    ::Swm_shiftpadreqdownType swm_shiftpadreqdown;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(swm_acctaugapsetplus);
        fun(swm_accvsetminus);
        fun(swm_shiftpadrequp);
        fun(swm_acclimphomests);
        fun(swm_laneassistswitch);
        fun(swm_acctaugapsetminus);
        fun(swm_accvsetplus);
        fun(swm_shiftpadflt);
        fun(swm_accdeactivate);
        fun(swm_accresume);
        fun(rolling_counter_0x31b);
        fun(swm_accenableswitch);
        fun(checksum_0x31b);
        fun(swm_accresume_qt);
        fun(swm_tjaswitch);
        fun(swm_shiftpadreqdown);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(swm_acctaugapsetplus);
        fun(swm_accvsetminus);
        fun(swm_shiftpadrequp);
        fun(swm_acclimphomests);
        fun(swm_laneassistswitch);
        fun(swm_acctaugapsetminus);
        fun(swm_accvsetplus);
        fun(swm_shiftpadflt);
        fun(swm_accdeactivate);
        fun(swm_accresume);
        fun(rolling_counter_0x31b);
        fun(swm_accenableswitch);
        fun(checksum_0x31b);
        fun(swm_accresume_qt);
        fun(swm_tjaswitch);
        fun(swm_shiftpadreqdown);
    }

    bool operator == (const ::Gw_swm_mrr_0x31b_31b& t) const {
        return (swm_acctaugapsetplus == t.swm_acctaugapsetplus) && (swm_accvsetminus == t.swm_accvsetminus) && (swm_shiftpadrequp == t.swm_shiftpadrequp) && (swm_acclimphomests == t.swm_acclimphomests) && (swm_laneassistswitch == t.swm_laneassistswitch) && (swm_acctaugapsetminus == t.swm_acctaugapsetminus) && (swm_accvsetplus == t.swm_accvsetplus) && (swm_shiftpadflt == t.swm_shiftpadflt) && (swm_accdeactivate == t.swm_accdeactivate) && (swm_accresume == t.swm_accresume) && (rolling_counter_0x31b == t.rolling_counter_0x31b) && (swm_accenableswitch == t.swm_accenableswitch) && (checksum_0x31b == t.checksum_0x31b) && (swm_accresume_qt == t.swm_accresume_qt) && (swm_tjaswitch == t.swm_tjaswitch) && (swm_shiftpadreqdown == t.swm_shiftpadreqdown);
    }
};


#endif // impl_type_gw_swm_mrr_0x31b_31b_h
