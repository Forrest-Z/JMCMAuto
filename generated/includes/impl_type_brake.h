/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_brake_h
#define impl_type_brake_h































#include "impl_type_double.h"
#include "impl_type_bool.h"
#include "impl_type_int32.h"
#include "impl_type_hsamodetype.h"
#include "impl_type_hsastatustype.h"


struct Brake {
    ::Bool is_brake_pedal_pressed;
    
    ::Bool is_brake_force_exist;
    
    ::Bool is_brake_over_heat;
    
    ::Bool is_hand_brake_on;
    
    ::Double brake_pedal_position;
    
    ::Bool is_brake_valid;
    
    ::Double brake_input;
    
    ::Double brake_cmd;
    
    ::Double brake_output;
    
    ::Bool boo_input;
    
    ::Bool boo_cmd;
    
    ::Bool boo_output;
    
    ::Bool watchdog_applying_brakes;
    
    ::Int32 watchdog_source;
    
    ::Bool brake_enabled;
    
    ::Bool driver_override;
    
    ::Bool driver_activity;
    
    ::Bool watchdog_fault;
    
    ::Bool channel_1_fault;
    
    ::Bool channel_2_fault;
    
    ::Bool boo_fault;
    
    ::Bool connector_fault;
    
    ::Double brake_torque_req;
    
    ::HSAStatusType hsa_status;
    
    ::Double brake_torque_act;
    
    ::HSAModeType hsa_mode;
    
    ::Double wheel_torque_act;
    
    ::Int32 major_version;
    
    ::Int32 minor_version;
    
    ::Int32 build_number;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(is_brake_pedal_pressed);
        fun(is_brake_force_exist);
        fun(is_brake_over_heat);
        fun(is_hand_brake_on);
        fun(brake_pedal_position);
        fun(is_brake_valid);
        fun(brake_input);
        fun(brake_cmd);
        fun(brake_output);
        fun(boo_input);
        fun(boo_cmd);
        fun(boo_output);
        fun(watchdog_applying_brakes);
        fun(watchdog_source);
        fun(brake_enabled);
        fun(driver_override);
        fun(driver_activity);
        fun(watchdog_fault);
        fun(channel_1_fault);
        fun(channel_2_fault);
        fun(boo_fault);
        fun(connector_fault);
        fun(brake_torque_req);
        fun(hsa_status);
        fun(brake_torque_act);
        fun(hsa_mode);
        fun(wheel_torque_act);
        fun(major_version);
        fun(minor_version);
        fun(build_number);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(is_brake_pedal_pressed);
        fun(is_brake_force_exist);
        fun(is_brake_over_heat);
        fun(is_hand_brake_on);
        fun(brake_pedal_position);
        fun(is_brake_valid);
        fun(brake_input);
        fun(brake_cmd);
        fun(brake_output);
        fun(boo_input);
        fun(boo_cmd);
        fun(boo_output);
        fun(watchdog_applying_brakes);
        fun(watchdog_source);
        fun(brake_enabled);
        fun(driver_override);
        fun(driver_activity);
        fun(watchdog_fault);
        fun(channel_1_fault);
        fun(channel_2_fault);
        fun(boo_fault);
        fun(connector_fault);
        fun(brake_torque_req);
        fun(hsa_status);
        fun(brake_torque_act);
        fun(hsa_mode);
        fun(wheel_torque_act);
        fun(major_version);
        fun(minor_version);
        fun(build_number);
    }

    bool operator == (const ::Brake& t) const {
        return (is_brake_pedal_pressed == t.is_brake_pedal_pressed) && (is_brake_force_exist == t.is_brake_force_exist) && (is_brake_over_heat == t.is_brake_over_heat) && (is_hand_brake_on == t.is_hand_brake_on) && (brake_pedal_position == t.brake_pedal_position) && (is_brake_valid == t.is_brake_valid) && (brake_input == t.brake_input) && (brake_cmd == t.brake_cmd) && (brake_output == t.brake_output) && (boo_input == t.boo_input) && (boo_cmd == t.boo_cmd) && (boo_output == t.boo_output) && (watchdog_applying_brakes == t.watchdog_applying_brakes) && (watchdog_source == t.watchdog_source) && (brake_enabled == t.brake_enabled) && (driver_override == t.driver_override) && (driver_activity == t.driver_activity) && (watchdog_fault == t.watchdog_fault) && (channel_1_fault == t.channel_1_fault) && (channel_2_fault == t.channel_2_fault) && (boo_fault == t.boo_fault) && (connector_fault == t.connector_fault) && (brake_torque_req == t.brake_torque_req) && (hsa_status == t.hsa_status) && (brake_torque_act == t.brake_torque_act) && (hsa_mode == t.hsa_mode) && (wheel_torque_act == t.wheel_torque_act) && (major_version == t.major_version) && (minor_version == t.minor_version) && (build_number == t.build_number);
    }
};


#endif // impl_type_brake_h
