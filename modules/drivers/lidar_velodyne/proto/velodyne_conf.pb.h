// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/drivers/lidar_velodyne/proto/velodyne_conf.proto

#ifndef PROTOBUF_modules_2fdrivers_2flidar_5fvelodyne_2fproto_2fvelodyne_5fconf_2eproto__INCLUDED
#define PROTOBUF_modules_2fdrivers_2flidar_5fvelodyne_2fproto_2fvelodyne_5fconf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace jmc_auto {
namespace drivers {
namespace lidar_velodyne {
class FusionConf;
class FusionConfDefaultTypeInternal;
extern FusionConfDefaultTypeInternal _FusionConf_default_instance_;
class VelodyneConf;
class VelodyneConfDefaultTypeInternal;
extern VelodyneConfDefaultTypeInternal _VelodyneConf_default_instance_;
class VelodyneConfUnit;
class VelodyneConfUnitDefaultTypeInternal;
extern VelodyneConfUnitDefaultTypeInternal _VelodyneConfUnit_default_instance_;
}  // namespace lidar_velodyne
}  // namespace drivers
}  // namespace jmc_auto

namespace jmc_auto {
namespace drivers {
namespace lidar_velodyne {

namespace protobuf_modules_2fdrivers_2flidar_5fvelodyne_2fproto_2fvelodyne_5fconf_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_modules_2fdrivers_2flidar_5fvelodyne_2fproto_2fvelodyne_5fconf_2eproto

enum VelodyneModel {
  VLP16 = 0,
  V64E_S2 = 1,
  V64E_S3S = 2,
  V64E_S3D_STRONGEST = 3,
  V64E_S3D_LAST = 4,
  V64E_S3D_DUAL = 5
};
bool VelodyneModel_IsValid(int value);
const VelodyneModel VelodyneModel_MIN = VLP16;
const VelodyneModel VelodyneModel_MAX = V64E_S3D_DUAL;
const int VelodyneModel_ARRAYSIZE = VelodyneModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* VelodyneModel_descriptor();
inline const ::std::string& VelodyneModel_Name(VelodyneModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    VelodyneModel_descriptor(), value);
}
inline bool VelodyneModel_Parse(
    const ::std::string& name, VelodyneModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VelodyneModel>(
    VelodyneModel_descriptor(), name, value);
}
// ===================================================================

class VelodyneConf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.lidar_velodyne.VelodyneConf) */ {
 public:
  VelodyneConf();
  virtual ~VelodyneConf();

  VelodyneConf(const VelodyneConf& from);

  inline VelodyneConf& operator=(const VelodyneConf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VelodyneConf& default_instance();

  static inline const VelodyneConf* internal_default_instance() {
    return reinterpret_cast<const VelodyneConf*>(
               &_VelodyneConf_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VelodyneConf* other);

  // implements Message ----------------------------------------------

  inline VelodyneConf* New() const PROTOBUF_FINAL { return New(NULL); }

  VelodyneConf* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VelodyneConf& from);
  void MergeFrom(const VelodyneConf& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VelodyneConf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string position = 2 [default = "centre"];
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::std::string& position() const;
  void set_position(const ::std::string& value);
  #if LANG_CXX11
  void set_position(::std::string&& value);
  #endif
  void set_position(const char* value);
  void set_position(const char* value, size_t size);
  ::std::string* mutable_position();
  ::std::string* release_position();
  void set_allocated_position(::std::string* position);

  // optional string frame_id = 3;
  bool has_frame_id() const;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 3;
  const ::std::string& frame_id() const;
  void set_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_frame_id(::std::string&& value);
  #endif
  void set_frame_id(const char* value);
  void set_frame_id(const char* value, size_t size);
  ::std::string* mutable_frame_id();
  ::std::string* release_frame_id();
  void set_allocated_frame_id(::std::string* frame_id);

  // optional string calibration_file = 108;
  bool has_calibration_file() const;
  void clear_calibration_file();
  static const int kCalibrationFileFieldNumber = 108;
  const ::std::string& calibration_file() const;
  void set_calibration_file(const ::std::string& value);
  #if LANG_CXX11
  void set_calibration_file(::std::string&& value);
  #endif
  void set_calibration_file(const char* value);
  void set_calibration_file(const char* value, size_t size);
  ::std::string* mutable_calibration_file();
  ::std::string* release_calibration_file();
  void set_allocated_calibration_file(::std::string* calibration_file);

  // optional string child_frame_id = 200 [default = "velodyne16"];
  bool has_child_frame_id() const;
  void clear_child_frame_id();
  static const int kChildFrameIdFieldNumber = 200;
  const ::std::string& child_frame_id() const;
  void set_child_frame_id(const ::std::string& value);
  #if LANG_CXX11
  void set_child_frame_id(::std::string&& value);
  #endif
  void set_child_frame_id(const char* value);
  void set_child_frame_id(const char* value, size_t size);
  ::std::string* mutable_child_frame_id();
  ::std::string* release_child_frame_id();
  void set_allocated_child_frame_id(::std::string* child_frame_id);

  // required uint32 index = 1 [default = 0];
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional .jmc_auto.drivers.lidar_velodyne.VelodyneModel model = 7 [default = VLP16];
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 7;
  ::jmc_auto::drivers::lidar_velodyne::VelodyneModel model() const;
  void set_model(::jmc_auto::drivers::lidar_velodyne::VelodyneModel value);

  // optional int32 npackets = 8;
  bool has_npackets() const;
  void clear_npackets();
  static const int kNpacketsFieldNumber = 8;
  ::google::protobuf::int32 npackets() const;
  void set_npackets(::google::protobuf::int32 value);

  // optional bool calibration_online = 106 [default = false];
  bool has_calibration_online() const;
  void clear_calibration_online();
  static const int kCalibrationOnlineFieldNumber = 106;
  bool calibration_online() const;
  void set_calibration_online(bool value);

  // optional bool organized = 107 [default = false];
  bool has_organized() const;
  void clear_organized();
  static const int kOrganizedFieldNumber = 107;
  bool organized() const;
  void set_organized(bool value);

  // optional double min_angle = 102;
  bool has_min_angle() const;
  void clear_min_angle();
  static const int kMinAngleFieldNumber = 102;
  double min_angle() const;
  void set_min_angle(double value);

  // optional double max_angle = 103;
  bool has_max_angle() const;
  void clear_max_angle();
  static const int kMaxAngleFieldNumber = 103;
  double max_angle() const;
  void set_max_angle(double value);

  // optional double view_direction = 104 [default = 0];
  bool has_view_direction() const;
  void clear_view_direction();
  static const int kViewDirectionFieldNumber = 104;
  double view_direction() const;
  void set_view_direction(double value);

  // optional uint32 firing_data_port = 4 [default = 2368];
  bool has_firing_data_port() const;
  void clear_firing_data_port();
  static const int kFiringDataPortFieldNumber = 4;
  ::google::protobuf::uint32 firing_data_port() const;
  void set_firing_data_port(::google::protobuf::uint32 value);

  // optional uint32 positioning_data_port = 5 [default = 8308];
  bool has_positioning_data_port() const;
  void clear_positioning_data_port();
  static const int kPositioningDataPortFieldNumber = 5;
  ::google::protobuf::uint32 positioning_data_port() const;
  void set_positioning_data_port(::google::protobuf::uint32 value);

  // optional double rpm = 6 [default = 600];
  bool has_rpm() const;
  void clear_rpm();
  static const int kRpmFieldNumber = 6;
  double rpm() const;
  void set_rpm(double value);

  // optional int32 cache_size = 9 [default = 1];
  bool has_cache_size() const;
  void clear_cache_size();
  static const int kCacheSizeFieldNumber = 9;
  ::google::protobuf::int32 cache_size() const;
  void set_cache_size(::google::protobuf::int32 value);

  // optional int32 packet_rate = 10 [default = 754];
  bool has_packet_rate() const;
  void clear_packet_rate();
  static const int kPacketRateFieldNumber = 10;
  ::google::protobuf::int32 packet_rate() const;
  void set_packet_rate(::google::protobuf::int32 value);

  // optional double max_range = 100 [default = 130];
  bool has_max_range() const;
  void clear_max_range();
  static const int kMaxRangeFieldNumber = 100;
  double max_range() const;
  void set_max_range(double value);

  // optional double min_range = 101 [default = 0.9];
  bool has_min_range() const;
  void clear_min_range();
  static const int kMinRangeFieldNumber = 101;
  double min_range() const;
  void set_min_range(double value);

  // optional double view_width = 105 [default = 6.2831853071795862];
  bool has_view_width() const;
  void clear_view_width();
  static const int kViewWidthFieldNumber = 105;
  double view_width() const;
  void set_view_width(double value);

  // optional double tf_query_timeout = 201 [default = 0.1];
  bool has_tf_query_timeout() const;
  void clear_tf_query_timeout();
  static const int kTfQueryTimeoutFieldNumber = 201;
  double tf_query_timeout() const;
  void set_tf_query_timeout(double value);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.lidar_velodyne.VelodyneConf)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_position();
  void clear_has_position();
  void set_has_frame_id();
  void clear_has_frame_id();
  void set_has_firing_data_port();
  void clear_has_firing_data_port();
  void set_has_positioning_data_port();
  void clear_has_positioning_data_port();
  void set_has_rpm();
  void clear_has_rpm();
  void set_has_model();
  void clear_has_model();
  void set_has_npackets();
  void clear_has_npackets();
  void set_has_cache_size();
  void clear_has_cache_size();
  void set_has_packet_rate();
  void clear_has_packet_rate();
  void set_has_max_range();
  void clear_has_max_range();
  void set_has_min_range();
  void clear_has_min_range();
  void set_has_min_angle();
  void clear_has_min_angle();
  void set_has_max_angle();
  void clear_has_max_angle();
  void set_has_view_direction();
  void clear_has_view_direction();
  void set_has_view_width();
  void clear_has_view_width();
  void set_has_calibration_online();
  void clear_has_calibration_online();
  void set_has_organized();
  void clear_has_organized();
  void set_has_calibration_file();
  void clear_has_calibration_file();
  void set_has_child_frame_id();
  void clear_has_child_frame_id();
  void set_has_tf_query_timeout();
  void clear_has_tf_query_timeout();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_position_;
  ::google::protobuf::internal::ArenaStringPtr position_;
  ::google::protobuf::internal::ArenaStringPtr frame_id_;
  ::google::protobuf::internal::ArenaStringPtr calibration_file_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_child_frame_id_;
  ::google::protobuf::internal::ArenaStringPtr child_frame_id_;
  ::google::protobuf::uint32 index_;
  int model_;
  ::google::protobuf::int32 npackets_;
  bool calibration_online_;
  bool organized_;
  double min_angle_;
  double max_angle_;
  double view_direction_;
  ::google::protobuf::uint32 firing_data_port_;
  ::google::protobuf::uint32 positioning_data_port_;
  double rpm_;
  ::google::protobuf::int32 cache_size_;
  ::google::protobuf::int32 packet_rate_;
  double max_range_;
  double min_range_;
  double view_width_;
  double tf_query_timeout_;
  friend struct protobuf_modules_2fdrivers_2flidar_5fvelodyne_2fproto_2fvelodyne_5fconf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FusionConf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.lidar_velodyne.FusionConf) */ {
 public:
  FusionConf();
  virtual ~FusionConf();

  FusionConf(const FusionConf& from);

  inline FusionConf& operator=(const FusionConf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FusionConf& default_instance();

  static inline const FusionConf* internal_default_instance() {
    return reinterpret_cast<const FusionConf*>(
               &_FusionConf_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(FusionConf* other);

  // implements Message ----------------------------------------------

  inline FusionConf* New() const PROTOBUF_FINAL { return New(NULL); }

  FusionConf* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FusionConf& from);
  void MergeFrom(const FusionConf& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FusionConf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 slave_index = 2;
  int slave_index_size() const;
  void clear_slave_index();
  static const int kSlaveIndexFieldNumber = 2;
  ::google::protobuf::uint32 slave_index(int index) const;
  void set_slave_index(int index, ::google::protobuf::uint32 value);
  void add_slave_index(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      slave_index() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_slave_index();

  // required uint32 major_index = 1 [default = 0];
  bool has_major_index() const;
  void clear_major_index();
  static const int kMajorIndexFieldNumber = 1;
  ::google::protobuf::uint32 major_index() const;
  void set_major_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.lidar_velodyne.FusionConf)
 private:
  void set_has_major_index();
  void clear_has_major_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > slave_index_;
  ::google::protobuf::uint32 major_index_;
  friend struct protobuf_modules_2fdrivers_2flidar_5fvelodyne_2fproto_2fvelodyne_5fconf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VelodyneConfUnit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit) */ {
 public:
  VelodyneConfUnit();
  virtual ~VelodyneConfUnit();

  VelodyneConfUnit(const VelodyneConfUnit& from);

  inline VelodyneConfUnit& operator=(const VelodyneConfUnit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VelodyneConfUnit& default_instance();

  static inline const VelodyneConfUnit* internal_default_instance() {
    return reinterpret_cast<const VelodyneConfUnit*>(
               &_VelodyneConfUnit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(VelodyneConfUnit* other);

  // implements Message ----------------------------------------------

  inline VelodyneConfUnit* New() const PROTOBUF_FINAL { return New(NULL); }

  VelodyneConfUnit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VelodyneConfUnit& from);
  void MergeFrom(const VelodyneConfUnit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VelodyneConfUnit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .jmc_auto.drivers.lidar_velodyne.VelodyneConf conf = 1;
  int conf_size() const;
  void clear_conf();
  static const int kConfFieldNumber = 1;
  const ::jmc_auto::drivers::lidar_velodyne::VelodyneConf& conf(int index) const;
  ::jmc_auto::drivers::lidar_velodyne::VelodyneConf* mutable_conf(int index);
  ::jmc_auto::drivers::lidar_velodyne::VelodyneConf* add_conf();
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::drivers::lidar_velodyne::VelodyneConf >*
      mutable_conf();
  const ::google::protobuf::RepeatedPtrField< ::jmc_auto::drivers::lidar_velodyne::VelodyneConf >&
      conf() const;

  // optional .jmc_auto.drivers.lidar_velodyne.FusionConf fusion_conf = 3;
  bool has_fusion_conf() const;
  void clear_fusion_conf();
  static const int kFusionConfFieldNumber = 3;
  const ::jmc_auto::drivers::lidar_velodyne::FusionConf& fusion_conf() const;
  ::jmc_auto::drivers::lidar_velodyne::FusionConf* mutable_fusion_conf();
  ::jmc_auto::drivers::lidar_velodyne::FusionConf* release_fusion_conf();
  void set_allocated_fusion_conf(::jmc_auto::drivers::lidar_velodyne::FusionConf* fusion_conf);

  // optional bool is_fusion = 2 [default = false];
  bool has_is_fusion() const;
  void clear_is_fusion();
  static const int kIsFusionFieldNumber = 2;
  bool is_fusion() const;
  void set_is_fusion(bool value);

  // @@protoc_insertion_point(class_scope:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit)
 private:
  void set_has_is_fusion();
  void clear_has_is_fusion();
  void set_has_fusion_conf();
  void clear_has_fusion_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::jmc_auto::drivers::lidar_velodyne::VelodyneConf > conf_;
  ::jmc_auto::drivers::lidar_velodyne::FusionConf* fusion_conf_;
  bool is_fusion_;
  friend struct protobuf_modules_2fdrivers_2flidar_5fvelodyne_2fproto_2fvelodyne_5fconf_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// VelodyneConf

// required uint32 index = 1 [default = 0];
inline bool VelodyneConf::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VelodyneConf::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VelodyneConf::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VelodyneConf::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 VelodyneConf::index() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.index)
  return index_;
}
inline void VelodyneConf::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.index)
}

// optional string position = 2 [default = "centre"];
inline bool VelodyneConf::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VelodyneConf::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VelodyneConf::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VelodyneConf::clear_position() {
  position_.ClearToDefaultNoArena(&VelodyneConf::_default_position_.get());
  clear_has_position();
}
inline const ::std::string& VelodyneConf::position() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.position)
  return position_.GetNoArena();
}
inline void VelodyneConf::set_position(const ::std::string& value) {
  set_has_position();
  position_.SetNoArena(&VelodyneConf::_default_position_.get(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.position)
}
#if LANG_CXX11
inline void VelodyneConf::set_position(::std::string&& value) {
  set_has_position();
  position_.SetNoArena(
    &VelodyneConf::_default_position_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.lidar_velodyne.VelodyneConf.position)
}
#endif
inline void VelodyneConf::set_position(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_position();
  position_.SetNoArena(&VelodyneConf::_default_position_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.lidar_velodyne.VelodyneConf.position)
}
inline void VelodyneConf::set_position(const char* value, size_t size) {
  set_has_position();
  position_.SetNoArena(&VelodyneConf::_default_position_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.lidar_velodyne.VelodyneConf.position)
}
inline ::std::string* VelodyneConf::mutable_position() {
  set_has_position();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.lidar_velodyne.VelodyneConf.position)
  return position_.MutableNoArena(&VelodyneConf::_default_position_.get());
}
inline ::std::string* VelodyneConf::release_position() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.lidar_velodyne.VelodyneConf.position)
  clear_has_position();
  return position_.ReleaseNoArena(&VelodyneConf::_default_position_.get());
}
inline void VelodyneConf::set_allocated_position(::std::string* position) {
  if (position != NULL) {
    set_has_position();
  } else {
    clear_has_position();
  }
  position_.SetAllocatedNoArena(&VelodyneConf::_default_position_.get(), position);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.lidar_velodyne.VelodyneConf.position)
}

// optional string frame_id = 3;
inline bool VelodyneConf::has_frame_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VelodyneConf::set_has_frame_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VelodyneConf::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VelodyneConf::clear_frame_id() {
  frame_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_frame_id();
}
inline const ::std::string& VelodyneConf::frame_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.frame_id)
  return frame_id_.GetNoArena();
}
inline void VelodyneConf::set_frame_id(const ::std::string& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.frame_id)
}
#if LANG_CXX11
inline void VelodyneConf::set_frame_id(::std::string&& value) {
  set_has_frame_id();
  frame_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.lidar_velodyne.VelodyneConf.frame_id)
}
#endif
inline void VelodyneConf::set_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.lidar_velodyne.VelodyneConf.frame_id)
}
inline void VelodyneConf::set_frame_id(const char* value, size_t size) {
  set_has_frame_id();
  frame_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.lidar_velodyne.VelodyneConf.frame_id)
}
inline ::std::string* VelodyneConf::mutable_frame_id() {
  set_has_frame_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.lidar_velodyne.VelodyneConf.frame_id)
  return frame_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VelodyneConf::release_frame_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.lidar_velodyne.VelodyneConf.frame_id)
  clear_has_frame_id();
  return frame_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VelodyneConf::set_allocated_frame_id(::std::string* frame_id) {
  if (frame_id != NULL) {
    set_has_frame_id();
  } else {
    clear_has_frame_id();
  }
  frame_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.lidar_velodyne.VelodyneConf.frame_id)
}

// optional uint32 firing_data_port = 4 [default = 2368];
inline bool VelodyneConf::has_firing_data_port() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VelodyneConf::set_has_firing_data_port() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VelodyneConf::clear_has_firing_data_port() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VelodyneConf::clear_firing_data_port() {
  firing_data_port_ = 2368u;
  clear_has_firing_data_port();
}
inline ::google::protobuf::uint32 VelodyneConf::firing_data_port() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.firing_data_port)
  return firing_data_port_;
}
inline void VelodyneConf::set_firing_data_port(::google::protobuf::uint32 value) {
  set_has_firing_data_port();
  firing_data_port_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.firing_data_port)
}

// optional uint32 positioning_data_port = 5 [default = 8308];
inline bool VelodyneConf::has_positioning_data_port() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VelodyneConf::set_has_positioning_data_port() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VelodyneConf::clear_has_positioning_data_port() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VelodyneConf::clear_positioning_data_port() {
  positioning_data_port_ = 8308u;
  clear_has_positioning_data_port();
}
inline ::google::protobuf::uint32 VelodyneConf::positioning_data_port() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.positioning_data_port)
  return positioning_data_port_;
}
inline void VelodyneConf::set_positioning_data_port(::google::protobuf::uint32 value) {
  set_has_positioning_data_port();
  positioning_data_port_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.positioning_data_port)
}

// optional double rpm = 6 [default = 600];
inline bool VelodyneConf::has_rpm() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VelodyneConf::set_has_rpm() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VelodyneConf::clear_has_rpm() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VelodyneConf::clear_rpm() {
  rpm_ = 600;
  clear_has_rpm();
}
inline double VelodyneConf::rpm() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.rpm)
  return rpm_;
}
inline void VelodyneConf::set_rpm(double value) {
  set_has_rpm();
  rpm_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.rpm)
}

// optional .jmc_auto.drivers.lidar_velodyne.VelodyneModel model = 7 [default = VLP16];
inline bool VelodyneConf::has_model() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VelodyneConf::set_has_model() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VelodyneConf::clear_has_model() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VelodyneConf::clear_model() {
  model_ = 0;
  clear_has_model();
}
inline ::jmc_auto::drivers::lidar_velodyne::VelodyneModel VelodyneConf::model() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.model)
  return static_cast< ::jmc_auto::drivers::lidar_velodyne::VelodyneModel >(model_);
}
inline void VelodyneConf::set_model(::jmc_auto::drivers::lidar_velodyne::VelodyneModel value) {
  assert(::jmc_auto::drivers::lidar_velodyne::VelodyneModel_IsValid(value));
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.model)
}

// optional int32 npackets = 8;
inline bool VelodyneConf::has_npackets() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VelodyneConf::set_has_npackets() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VelodyneConf::clear_has_npackets() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VelodyneConf::clear_npackets() {
  npackets_ = 0;
  clear_has_npackets();
}
inline ::google::protobuf::int32 VelodyneConf::npackets() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.npackets)
  return npackets_;
}
inline void VelodyneConf::set_npackets(::google::protobuf::int32 value) {
  set_has_npackets();
  npackets_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.npackets)
}

// optional int32 cache_size = 9 [default = 1];
inline bool VelodyneConf::has_cache_size() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VelodyneConf::set_has_cache_size() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VelodyneConf::clear_has_cache_size() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VelodyneConf::clear_cache_size() {
  cache_size_ = 1;
  clear_has_cache_size();
}
inline ::google::protobuf::int32 VelodyneConf::cache_size() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.cache_size)
  return cache_size_;
}
inline void VelodyneConf::set_cache_size(::google::protobuf::int32 value) {
  set_has_cache_size();
  cache_size_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.cache_size)
}

// optional int32 packet_rate = 10 [default = 754];
inline bool VelodyneConf::has_packet_rate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VelodyneConf::set_has_packet_rate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VelodyneConf::clear_has_packet_rate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VelodyneConf::clear_packet_rate() {
  packet_rate_ = 754;
  clear_has_packet_rate();
}
inline ::google::protobuf::int32 VelodyneConf::packet_rate() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.packet_rate)
  return packet_rate_;
}
inline void VelodyneConf::set_packet_rate(::google::protobuf::int32 value) {
  set_has_packet_rate();
  packet_rate_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.packet_rate)
}

// optional double max_range = 100 [default = 130];
inline bool VelodyneConf::has_max_range() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VelodyneConf::set_has_max_range() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VelodyneConf::clear_has_max_range() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VelodyneConf::clear_max_range() {
  max_range_ = 130;
  clear_has_max_range();
}
inline double VelodyneConf::max_range() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.max_range)
  return max_range_;
}
inline void VelodyneConf::set_max_range(double value) {
  set_has_max_range();
  max_range_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.max_range)
}

// optional double min_range = 101 [default = 0.9];
inline bool VelodyneConf::has_min_range() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VelodyneConf::set_has_min_range() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VelodyneConf::clear_has_min_range() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VelodyneConf::clear_min_range() {
  min_range_ = 0.9;
  clear_has_min_range();
}
inline double VelodyneConf::min_range() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.min_range)
  return min_range_;
}
inline void VelodyneConf::set_min_range(double value) {
  set_has_min_range();
  min_range_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.min_range)
}

// optional double min_angle = 102;
inline bool VelodyneConf::has_min_angle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VelodyneConf::set_has_min_angle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VelodyneConf::clear_has_min_angle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VelodyneConf::clear_min_angle() {
  min_angle_ = 0;
  clear_has_min_angle();
}
inline double VelodyneConf::min_angle() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.min_angle)
  return min_angle_;
}
inline void VelodyneConf::set_min_angle(double value) {
  set_has_min_angle();
  min_angle_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.min_angle)
}

// optional double max_angle = 103;
inline bool VelodyneConf::has_max_angle() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VelodyneConf::set_has_max_angle() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VelodyneConf::clear_has_max_angle() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VelodyneConf::clear_max_angle() {
  max_angle_ = 0;
  clear_has_max_angle();
}
inline double VelodyneConf::max_angle() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.max_angle)
  return max_angle_;
}
inline void VelodyneConf::set_max_angle(double value) {
  set_has_max_angle();
  max_angle_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.max_angle)
}

// optional double view_direction = 104 [default = 0];
inline bool VelodyneConf::has_view_direction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VelodyneConf::set_has_view_direction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VelodyneConf::clear_has_view_direction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VelodyneConf::clear_view_direction() {
  view_direction_ = 0;
  clear_has_view_direction();
}
inline double VelodyneConf::view_direction() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.view_direction)
  return view_direction_;
}
inline void VelodyneConf::set_view_direction(double value) {
  set_has_view_direction();
  view_direction_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.view_direction)
}

// optional double view_width = 105 [default = 6.2831853071795862];
inline bool VelodyneConf::has_view_width() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void VelodyneConf::set_has_view_width() {
  _has_bits_[0] |= 0x00080000u;
}
inline void VelodyneConf::clear_has_view_width() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void VelodyneConf::clear_view_width() {
  view_width_ = 6.2831853071795862;
  clear_has_view_width();
}
inline double VelodyneConf::view_width() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.view_width)
  return view_width_;
}
inline void VelodyneConf::set_view_width(double value) {
  set_has_view_width();
  view_width_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.view_width)
}

// optional bool calibration_online = 106 [default = false];
inline bool VelodyneConf::has_calibration_online() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VelodyneConf::set_has_calibration_online() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VelodyneConf::clear_has_calibration_online() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VelodyneConf::clear_calibration_online() {
  calibration_online_ = false;
  clear_has_calibration_online();
}
inline bool VelodyneConf::calibration_online() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_online)
  return calibration_online_;
}
inline void VelodyneConf::set_calibration_online(bool value) {
  set_has_calibration_online();
  calibration_online_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_online)
}

// optional bool organized = 107 [default = false];
inline bool VelodyneConf::has_organized() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VelodyneConf::set_has_organized() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VelodyneConf::clear_has_organized() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VelodyneConf::clear_organized() {
  organized_ = false;
  clear_has_organized();
}
inline bool VelodyneConf::organized() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.organized)
  return organized_;
}
inline void VelodyneConf::set_organized(bool value) {
  set_has_organized();
  organized_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.organized)
}

// optional string calibration_file = 108;
inline bool VelodyneConf::has_calibration_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VelodyneConf::set_has_calibration_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VelodyneConf::clear_has_calibration_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VelodyneConf::clear_calibration_file() {
  calibration_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_calibration_file();
}
inline const ::std::string& VelodyneConf::calibration_file() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_file)
  return calibration_file_.GetNoArena();
}
inline void VelodyneConf::set_calibration_file(const ::std::string& value) {
  set_has_calibration_file();
  calibration_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_file)
}
#if LANG_CXX11
inline void VelodyneConf::set_calibration_file(::std::string&& value) {
  set_has_calibration_file();
  calibration_file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_file)
}
#endif
inline void VelodyneConf::set_calibration_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_calibration_file();
  calibration_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_file)
}
inline void VelodyneConf::set_calibration_file(const char* value, size_t size) {
  set_has_calibration_file();
  calibration_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_file)
}
inline ::std::string* VelodyneConf::mutable_calibration_file() {
  set_has_calibration_file();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_file)
  return calibration_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VelodyneConf::release_calibration_file() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_file)
  clear_has_calibration_file();
  return calibration_file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VelodyneConf::set_allocated_calibration_file(::std::string* calibration_file) {
  if (calibration_file != NULL) {
    set_has_calibration_file();
  } else {
    clear_has_calibration_file();
  }
  calibration_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), calibration_file);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.lidar_velodyne.VelodyneConf.calibration_file)
}

// optional string child_frame_id = 200 [default = "velodyne16"];
inline bool VelodyneConf::has_child_frame_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VelodyneConf::set_has_child_frame_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VelodyneConf::clear_has_child_frame_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VelodyneConf::clear_child_frame_id() {
  child_frame_id_.ClearToDefaultNoArena(&VelodyneConf::_default_child_frame_id_.get());
  clear_has_child_frame_id();
}
inline const ::std::string& VelodyneConf::child_frame_id() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.child_frame_id)
  return child_frame_id_.GetNoArena();
}
inline void VelodyneConf::set_child_frame_id(const ::std::string& value) {
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(&VelodyneConf::_default_child_frame_id_.get(), value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.child_frame_id)
}
#if LANG_CXX11
inline void VelodyneConf::set_child_frame_id(::std::string&& value) {
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(
    &VelodyneConf::_default_child_frame_id_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:jmc_auto.drivers.lidar_velodyne.VelodyneConf.child_frame_id)
}
#endif
inline void VelodyneConf::set_child_frame_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(&VelodyneConf::_default_child_frame_id_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:jmc_auto.drivers.lidar_velodyne.VelodyneConf.child_frame_id)
}
inline void VelodyneConf::set_child_frame_id(const char* value, size_t size) {
  set_has_child_frame_id();
  child_frame_id_.SetNoArena(&VelodyneConf::_default_child_frame_id_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:jmc_auto.drivers.lidar_velodyne.VelodyneConf.child_frame_id)
}
inline ::std::string* VelodyneConf::mutable_child_frame_id() {
  set_has_child_frame_id();
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.lidar_velodyne.VelodyneConf.child_frame_id)
  return child_frame_id_.MutableNoArena(&VelodyneConf::_default_child_frame_id_.get());
}
inline ::std::string* VelodyneConf::release_child_frame_id() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.lidar_velodyne.VelodyneConf.child_frame_id)
  clear_has_child_frame_id();
  return child_frame_id_.ReleaseNoArena(&VelodyneConf::_default_child_frame_id_.get());
}
inline void VelodyneConf::set_allocated_child_frame_id(::std::string* child_frame_id) {
  if (child_frame_id != NULL) {
    set_has_child_frame_id();
  } else {
    clear_has_child_frame_id();
  }
  child_frame_id_.SetAllocatedNoArena(&VelodyneConf::_default_child_frame_id_.get(), child_frame_id);
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.lidar_velodyne.VelodyneConf.child_frame_id)
}

// optional double tf_query_timeout = 201 [default = 0.1];
inline bool VelodyneConf::has_tf_query_timeout() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void VelodyneConf::set_has_tf_query_timeout() {
  _has_bits_[0] |= 0x00100000u;
}
inline void VelodyneConf::clear_has_tf_query_timeout() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void VelodyneConf::clear_tf_query_timeout() {
  tf_query_timeout_ = 0.1;
  clear_has_tf_query_timeout();
}
inline double VelodyneConf::tf_query_timeout() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConf.tf_query_timeout)
  return tf_query_timeout_;
}
inline void VelodyneConf::set_tf_query_timeout(double value) {
  set_has_tf_query_timeout();
  tf_query_timeout_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConf.tf_query_timeout)
}

// -------------------------------------------------------------------

// FusionConf

// required uint32 major_index = 1 [default = 0];
inline bool FusionConf::has_major_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FusionConf::set_has_major_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FusionConf::clear_has_major_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FusionConf::clear_major_index() {
  major_index_ = 0u;
  clear_has_major_index();
}
inline ::google::protobuf::uint32 FusionConf::major_index() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.FusionConf.major_index)
  return major_index_;
}
inline void FusionConf::set_major_index(::google::protobuf::uint32 value) {
  set_has_major_index();
  major_index_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.FusionConf.major_index)
}

// repeated uint32 slave_index = 2;
inline int FusionConf::slave_index_size() const {
  return slave_index_.size();
}
inline void FusionConf::clear_slave_index() {
  slave_index_.Clear();
}
inline ::google::protobuf::uint32 FusionConf::slave_index(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.FusionConf.slave_index)
  return slave_index_.Get(index);
}
inline void FusionConf::set_slave_index(int index, ::google::protobuf::uint32 value) {
  slave_index_.Set(index, value);
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.FusionConf.slave_index)
}
inline void FusionConf::add_slave_index(::google::protobuf::uint32 value) {
  slave_index_.Add(value);
  // @@protoc_insertion_point(field_add:jmc_auto.drivers.lidar_velodyne.FusionConf.slave_index)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
FusionConf::slave_index() const {
  // @@protoc_insertion_point(field_list:jmc_auto.drivers.lidar_velodyne.FusionConf.slave_index)
  return slave_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
FusionConf::mutable_slave_index() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.drivers.lidar_velodyne.FusionConf.slave_index)
  return &slave_index_;
}

// -------------------------------------------------------------------

// VelodyneConfUnit

// repeated .jmc_auto.drivers.lidar_velodyne.VelodyneConf conf = 1;
inline int VelodyneConfUnit::conf_size() const {
  return conf_.size();
}
inline void VelodyneConfUnit::clear_conf() {
  conf_.Clear();
}
inline const ::jmc_auto::drivers::lidar_velodyne::VelodyneConf& VelodyneConfUnit::conf(int index) const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.conf)
  return conf_.Get(index);
}
inline ::jmc_auto::drivers::lidar_velodyne::VelodyneConf* VelodyneConfUnit::mutable_conf(int index) {
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.conf)
  return conf_.Mutable(index);
}
inline ::jmc_auto::drivers::lidar_velodyne::VelodyneConf* VelodyneConfUnit::add_conf() {
  // @@protoc_insertion_point(field_add:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.conf)
  return conf_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::jmc_auto::drivers::lidar_velodyne::VelodyneConf >*
VelodyneConfUnit::mutable_conf() {
  // @@protoc_insertion_point(field_mutable_list:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.conf)
  return &conf_;
}
inline const ::google::protobuf::RepeatedPtrField< ::jmc_auto::drivers::lidar_velodyne::VelodyneConf >&
VelodyneConfUnit::conf() const {
  // @@protoc_insertion_point(field_list:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.conf)
  return conf_;
}

// optional bool is_fusion = 2 [default = false];
inline bool VelodyneConfUnit::has_is_fusion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VelodyneConfUnit::set_has_is_fusion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VelodyneConfUnit::clear_has_is_fusion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VelodyneConfUnit::clear_is_fusion() {
  is_fusion_ = false;
  clear_has_is_fusion();
}
inline bool VelodyneConfUnit::is_fusion() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.is_fusion)
  return is_fusion_;
}
inline void VelodyneConfUnit::set_is_fusion(bool value) {
  set_has_is_fusion();
  is_fusion_ = value;
  // @@protoc_insertion_point(field_set:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.is_fusion)
}

// optional .jmc_auto.drivers.lidar_velodyne.FusionConf fusion_conf = 3;
inline bool VelodyneConfUnit::has_fusion_conf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VelodyneConfUnit::set_has_fusion_conf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VelodyneConfUnit::clear_has_fusion_conf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VelodyneConfUnit::clear_fusion_conf() {
  if (fusion_conf_ != NULL) fusion_conf_->::jmc_auto::drivers::lidar_velodyne::FusionConf::Clear();
  clear_has_fusion_conf();
}
inline const ::jmc_auto::drivers::lidar_velodyne::FusionConf& VelodyneConfUnit::fusion_conf() const {
  // @@protoc_insertion_point(field_get:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.fusion_conf)
  return fusion_conf_ != NULL ? *fusion_conf_
                         : *::jmc_auto::drivers::lidar_velodyne::FusionConf::internal_default_instance();
}
inline ::jmc_auto::drivers::lidar_velodyne::FusionConf* VelodyneConfUnit::mutable_fusion_conf() {
  set_has_fusion_conf();
  if (fusion_conf_ == NULL) {
    fusion_conf_ = new ::jmc_auto::drivers::lidar_velodyne::FusionConf;
  }
  // @@protoc_insertion_point(field_mutable:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.fusion_conf)
  return fusion_conf_;
}
inline ::jmc_auto::drivers::lidar_velodyne::FusionConf* VelodyneConfUnit::release_fusion_conf() {
  // @@protoc_insertion_point(field_release:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.fusion_conf)
  clear_has_fusion_conf();
  ::jmc_auto::drivers::lidar_velodyne::FusionConf* temp = fusion_conf_;
  fusion_conf_ = NULL;
  return temp;
}
inline void VelodyneConfUnit::set_allocated_fusion_conf(::jmc_auto::drivers::lidar_velodyne::FusionConf* fusion_conf) {
  delete fusion_conf_;
  fusion_conf_ = fusion_conf;
  if (fusion_conf) {
    set_has_fusion_conf();
  } else {
    clear_has_fusion_conf();
  }
  // @@protoc_insertion_point(field_set_allocated:jmc_auto.drivers.lidar_velodyne.VelodyneConfUnit.fusion_conf)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace lidar_velodyne
}  // namespace drivers
}  // namespace jmc_auto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::jmc_auto::drivers::lidar_velodyne::VelodyneModel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::jmc_auto::drivers::lidar_velodyne::VelodyneModel>() {
  return ::jmc_auto::drivers::lidar_velodyne::VelodyneModel_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fdrivers_2flidar_5fvelodyne_2fproto_2fvelodyne_5fconf_2eproto__INCLUDED
