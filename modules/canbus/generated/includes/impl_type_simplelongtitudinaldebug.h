/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * Generated by VRTF CM-Generator
 */

#ifndef impl_type_simplelongtitudinaldebug_h
#define impl_type_simplelongtitudinaldebug_h


















#include "impl_type_double.h"
#include "impl_type_bool.h"


struct SimpleLongtitudinalDebug {
    ::Double station_reference;
    
    ::Double station_error;
    
    ::Double station_error_limited;
    
    ::Double preview_station_error;
    
    ::Double speed_reference;
    
    ::Double speed_vehicle;
    
    ::Double speed_error;
    
    ::Double speed_controller_input_limited;
    
    ::Double preview_speed_reference;
    
    ::Double preview_speed_error;
    
    ::Double preview_acceleration_reference;
    
    ::Double acceleration_cmd_closeloop;
    
    ::Double acceleration_cmd;
    
    ::Bool is_full_stop;
    
    ::Double slope_offset_compensation;
    
    ::Double current_station;
    
    ::Double path_remain;
    

    static bool IsPlane()
    {
        return true;
    }

    using IsEnumerableTag = void;
    template<typename F>
    void enumerate(F& fun)
    {
        fun(station_reference);
        fun(station_error);
        fun(station_error_limited);
        fun(preview_station_error);
        fun(speed_reference);
        fun(speed_vehicle);
        fun(speed_error);
        fun(speed_controller_input_limited);
        fun(preview_speed_reference);
        fun(preview_speed_error);
        fun(preview_acceleration_reference);
        fun(acceleration_cmd_closeloop);
        fun(acceleration_cmd);
        fun(is_full_stop);
        fun(slope_offset_compensation);
        fun(current_station);
        fun(path_remain);
    }

    template<typename F>
    void enumerate(F& fun) const
    {
        fun(station_reference);
        fun(station_error);
        fun(station_error_limited);
        fun(preview_station_error);
        fun(speed_reference);
        fun(speed_vehicle);
        fun(speed_error);
        fun(speed_controller_input_limited);
        fun(preview_speed_reference);
        fun(preview_speed_error);
        fun(preview_acceleration_reference);
        fun(acceleration_cmd_closeloop);
        fun(acceleration_cmd);
        fun(is_full_stop);
        fun(slope_offset_compensation);
        fun(current_station);
        fun(path_remain);
    }

    bool operator == (const ::SimpleLongtitudinalDebug& t) const {
        return (station_reference == t.station_reference) && (station_error == t.station_error) && (station_error_limited == t.station_error_limited) && (preview_station_error == t.preview_station_error) && (speed_reference == t.speed_reference) && (speed_vehicle == t.speed_vehicle) && (speed_error == t.speed_error) && (speed_controller_input_limited == t.speed_controller_input_limited) && (preview_speed_reference == t.preview_speed_reference) && (preview_speed_error == t.preview_speed_error) && (preview_acceleration_reference == t.preview_acceleration_reference) && (acceleration_cmd_closeloop == t.acceleration_cmd_closeloop) && (acceleration_cmd == t.acceleration_cmd) && (is_full_stop == t.is_full_stop) && (slope_offset_compensation == t.slope_offset_compensation) && (current_station == t.current_station) && (path_remain == t.path_remain);
    }
};


#endif // impl_type_simplelongtitudinaldebug_h
